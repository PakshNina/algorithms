/*
Алгоритм "Bucket Token".

В алгоритме есть виртуальное "ведро" (bucket), которое хранит токены.
Каждый токен представляет единицу разрешенной работы или использования ресурса.
Ведро наполняется токенами с определенной скоростью.
Эта скорость называется "наполнением" (refill rate) и измеряется в токенах в секунду (tokens per second).
Когда клиент хочет выполнить запрос или получить доступ к ресурсу, он должен потребовать у ведра определенное количество токенов для этой операции.
Если ведро содержит достаточное количество токенов, запрос или доступ разрешается, и количество токенов в ведре уменьшается на количество, использованное для этой операции.
Если ведро пусто или содержит недостаточное количество токенов, запрос или доступ может быть поставлен в ожидание или отклонен.

Использование:
1. Ограничение скорости трафика: ограничение частоты передачи данных или запросов на внешний сервер.
2. Ограничение доступа к API: ограничение частоты обращений к API со стороны клиентов, чтобы избежать перегрузки и повышенных нагрузок на серверы.
3. Сглаживание нагрузки: уменьшение пиковой нагрузки на систему.
4. Регулирование ресурсов: контроль использования системных ресурсов.
*/

package main

import "time"

import (
	"context"
	"fmt"
	"log"
	"sync"

	"golang.org/x/time/rate"
)

const (
	rateLimit = 5           // Количество запросов в период.
	period    = time.Second // Период.
	burst     = 1           // Количество запросов в пик.
)

func main() {
	var wg sync.WaitGroup
	waitToExecute(&wg)
	passWhenNoToken(&wg)
	wg.Wait()
}

func worker() int {
	return time.Now().Nanosecond()
}

// waitToExecute блокируем выполнение кода и ждем, пока будет доступен токен.
func waitToExecute(wg *sync.WaitGroup) {
	// Выполняет 5 запросов в 1 секунду с пиком в 1 запрос.
	tb := rate.NewLimiter(rate.Every(period/rateLimit), burst)

	for i := 0; i < 50; i++ {
		// Блокирующая операция: ожидаем появления токена.
		if err := tb.Wait(context.Background()); err != nil {
			log.Fatal(err)
		}
		wg.Add(1)
		go func() {
			defer wg.Done()
			worker()
		}()
	}
}

// passWhenNoToken выполняем код, когда есть доступные токены без блокировки.
func passWhenNoToken(wg *sync.WaitGroup) {
	// Доступно 5 запросов в период 1 секунда с пиком в 10 запросов.
	tb := rate.NewLimiter(rate.Every(period/rateLimit), 10)
	for i := 0; i < 50; i++ {
		// Неблокирующая операция: проверяем доступен ли токен.
		if tb.Allow() {
			wg.Add(1)
			go func() {
				defer wg.Done()
				worker()
			}()
		} else {
			fmt.Println("токен недоступен, попробуйте через некоторое время", i)
		}
	}
}
